#!/usr/bin/python
"""Creates a plot of the convergence of sparse grid vs product grid methods of
calculating current with kinetic and thermodynamic dispersion.
"""

import electrochemistry.tools.fileio as io
import electrochemistry.tools.solution_tools as st
import electrochemistry.tools.grid as gt
import numpy as np
import os.path
import matplotlib.pyplot as plt

PTS_PER_WAVE = 200

NUM_EVALUATIONS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 30, 40, 50, 60, 70]
BENCHMARK_NUM_EVALS = 70
HARMONIC = 10
PT_SEQ = [1, 3, 5, 9, 17, 33]
FILE_NAME = "./files/simulationParameters.json"
DATA_NAME = "Martin's experiment"

def l2_norm(x): #pylint: disable=invalid-name
    """Return the l2 norm of the input"""
    return np.sqrt(np.sum(np.square(x)))

def gen_file_name(name):
    """Return a path to be placed in the project files/disperison directory."""
    return io.get_file_resource_path("dispersion/" + name + ".npz")

def get_current_harmonic(time_step, num_time_pts, base_data, filename):
    """Return the harmonic of the current generated by the given base_data,
    or the harmonic of the current contained in filename, if filename exists.
    """
    freq = base_data["freq"]
    if os.path.exists(filename):
        _, current = io.read_time_current_data_bin(filename)
    else:
        current, time = st.solve_reaction_from_json(
            time_step, num_time_pts, base_data)
        io.write_time_current_bin_cmp(filename, time, current)
    return st.extract_harmonic(HARMONIC, freq * time_step * num_time_pts,
                               current)
def grid_hermgauss_product(
        num_pts, eq_pot_mean, eq_pot_stdev, eq_rate_mean, eq_rate_stdev):
    """Setup for the product grid"""
    pot_rule = lambda n: gt.hermgauss_param(
        n, eq_pot_mean, eq_pot_stdev, False)
    rate_rule = lambda n: gt.hermgauss_param(
        n, eq_rate_mean, eq_rate_stdev, True)

    return gt.product_grid(pot_rule, num_pts, rate_rule, num_pts)

def grid_hermgauss_sparse(
        level, eq_pot_mean, eq_pot_stdev, eq_rate_mean, eq_rate_stdev):
    """Setup for the sparse grid."""
    pot_rule = lambda n: gt.hermgauss_param(
        n, eq_pot_mean, eq_pot_stdev, False)
    rate_rule = lambda n: gt.hermgauss_param(
        n, eq_rate_mean, eq_rate_stdev, True)

    return gt.sparse_grid(pot_rule, rate_rule, level, PT_SEQ, PT_SEQ)


def main():
    """Run the script."""
    base_data = io.read_json_params(FILE_NAME, DATA_NAME)
    base_data["type"] = "disp-dimensional-bins"
    # Remove E_0, k_0 from the data and store them as means for
    # the distributions.
    eq_pot_mean = base_data.pop("eq_pot")
    eq_pot_stdev = 5e-3
    eq_rate_mean = base_data.pop("eq_rate")
    eq_rate_stdev = 2


    end_time = (base_data["pot_rev"] - base_data["pot_start"]) / base_data["nu"]
    num_time_pts = int(np.ceil(PTS_PER_WAVE * base_data["freq"] * 2 * end_time))
    time_step = end_time / (num_time_pts - 1)
    trim = int(np.floor(num_time_pts / 100))



    # Load benchmark data, or generate it

    sim_file_name = gen_file_name("benchmark")
    base_data["bins"] = grid_hermgauss_product(
        BENCHMARK_NUM_EVALS, eq_pot_mean, eq_pot_stdev,
        eq_rate_mean, eq_rate_stdev)
    harm_hr = get_current_harmonic(
        time_step, num_time_pts, base_data, sim_file_name)
    harm_norm = l2_norm(harm_hr[trim:-trim])
    print "Benchmark data loaded"
    print "Beginning processing for product grid"
    harm_err = []
    for num_samples in NUM_EVALUATIONS:
        # First, do product grids
        sim_file_name = gen_file_name("HermGauss"+str(num_samples)+"pts")
        base_data["bins"] = grid_hermgauss_product(
            num_samples, eq_pot_mean, eq_pot_stdev,
            eq_rate_mean, eq_rate_stdev)
        harm = get_current_harmonic(time_step, num_time_pts,
                                    base_data, sim_file_name)
        harm_err.append(
            l2_norm(harm_hr[trim:-trim] - harm[trim:-trim]) / harm_norm)
        print "Data for {0} samples loaded".format(num_samples)

    plt.title("Convergence in the 10th harmonic")
    plt.loglog(NUM_EVALUATIONS, harm_err)

    num_grid_pts = []
    harm_err = []
    print "Beginning processing for sparse grid"
    for level in range(1, len(PT_SEQ)):
        num_grid_pts.append(
            np.sum(np.array(PT_SEQ[:level]) \
            * np.array(list(reversed(PT_SEQ[:level]))))\
            + np.sum(np.array(PT_SEQ[:level - 1])\
            * np.array(list(reversed(PT_SEQ[:level - 1])))))
        sim_file_name = gen_file_name("HermGaussSparse"+str(level)+"level")
        base_data["bins"] = grid_hermgauss_sparse(
            level, eq_pot_mean, eq_pot_stdev,
            eq_rate_mean, eq_rate_stdev)
        harm = get_current_harmonic(time_step, num_time_pts,
                                    base_data, sim_file_name)
        harm_err.append(
            l2_norm(harm_hr[trim:-trim] - harm[trim:-trim]) / harm_norm)
        print "Data for level {0} loaded.".format(level)
    plt.loglog(num_grid_pts, harm_err)
    plt.savefig("./files/convPlots/sparseVsProduct.pdf")
    plt.show()

if __name__ == "__main__":
    main()

